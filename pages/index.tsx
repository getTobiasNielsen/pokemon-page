import { useState, useEffect } from "react";
import Head from "next/head";
import Image from "next/image";
import TopBar from "../components/TopBar";
import DarkModeToggle from "../components/DarkModeToggle";
import PokemonCard from "../components/PokemonCard";
import Pagination from "../components/Pagination";
import { GetServerSideProps } from "next";
import { PokemonClient, Pokemon } from "pokenode-ts";
import _ from "lodash";
import { ParsedUrlQuery } from "querystring";
import { getCookie } from "cookies-next";
import { IncomingMessage, ServerResponse } from "node:http";
import Router, { useRouter } from "next/router";
import { Loader } from "@mantine/core";

export default function Home({
  pokemon,
  errorMsg,
  initialLimit,
  initalFilter,
  itemsCount,
  currentPage,
}: {
  pokemon: Partial<Pokemon>[];
  errorMsg: string;
  initialLimit: string;
  initalFilter: string;
  itemsCount: number;
  currentPage: string;
}) {
  const router = useRouter();

  const [searchValue, setSearchValue] = useState("");
  const [searchResult, setSearchResult] = useState<
    Partial<Pokemon>[] | undefined
  >();
  const [loading, setLoading] = useState(false);
  const startLoading = () => setLoading(true);
  const stopLoading = () => setLoading(false);

  useEffect(() => {
    const afterSearchFilter = pokemon?.filter((p) =>
      p.name?.toLowerCase().includes(searchValue.toLowerCase())
    );
    setSearchResult(afterSearchFilter);
  }, [searchValue, pokemon]);

  useEffect(() => {
    Router.events.on("routeChangeStart", startLoading);
    Router.events.on("routeChangeComplete", stopLoading);
    return () => {
      Router.events.off("routeChangeStart", startLoading);
      Router.events.off("routeChangeComplete", stopLoading);
    };
  }, []);

  const handlePageChange = (
    e: React.MouseEvent<HTMLAnchorElement>,
    page: number
  ) => {
    e.preventDefault();
    const path = router.pathname;
    const query = router.query;
    query.page = page.toString();
    router.push({
      pathname: path,
      query: router.query,
    });
  };

  if (errorMsg) return <div>{errorMsg}</div>;

  return (
    <div className="h-full min-h-full">
      <Head>
        <title>Pokemon</title>
        <meta name="description" content="Generated by create next app" />
      </Head>
      <TopBar
        initialLimit={initialLimit}
        initalFilter={initalFilter}
        searchValue={searchValue}
        setSearchValue={setSearchValue}
      />

      <div className="grid grid-cols-[minmax(0,1fr),auto,minmax(0,1fr)] items-center max-w-6xl mx-auto px-5 sm:px-0">
        <div></div>
        <div>
          <Pagination
            pageSize={initialLimit as unknown as number}
            itemsCount={itemsCount}
            currentPage={currentPage}
            onPageChange={handlePageChange}
          />
        </div>
        <div className="ml-auto">
          <DarkModeToggle />
        </div>
      </div>
      <main className="h-full max-w-6xl mx-auto px-5 sm:px-0">
        {loading ? (
          <div>
            <Loader className="mx-auto" />
          </div>
        ) : (
          <>
            {searchResult && searchResult.length > 0 ? (
              <div className="place-items-center grid gap-8 grid-cols-1 sm:grid-cols-2 md:grid-cols-4">
                {searchResult.map((p: any) => (
                  <PokemonCard key={p.id} pokemon={p} />
                ))}
              </div>
            ) : (
              <div>No pokemon found</div>
            )}
          </>
        )}
        {!loading ? (
          <div className="py-10 grid grid-cols-[minmax(0,1fr),auto,minmax(0,1fr)] items-center max-w-6xl mx-auto px-5 sm:px-0">
            <div></div>
            <div>
              <Pagination
                pageSize={initialLimit as unknown as number}
                itemsCount={itemsCount}
                currentPage={currentPage}
                onPageChange={handlePageChange}
              />
            </div>
            <div></div>
          </div>
        ) : null}
      </main>
    </div>
  );
}

export const getServerSideProps: GetServerSideProps = async ({
  res,
  req,
  query,
}) => {
  // Enabled cache control
  // 'public', because there is no sensitive information
  // 's-maxage' 10mins before the cache is considered stale,
  // 'stale-while-revalidate' stale version available for the next 10 mins after it becomes stale
  res.setHeader(
    "Cache-Control",
    "public, s-maxage=600, stale-while-revalidate=1200"
  );

  const page = query.page || 1;
  const limit = resolveQueryLimit(req, res, query);
  const filter = resolveQueryFilter(req, res, query);

  const offset = ((page as number) - 1) * limit;

  try {
    const api = new PokemonClient({
      cacheOptions: { maxAge: 1000 * 60 * 60 * 24 * 7 },
    });

    const pokemonList = await api.listPokemons(offset, limit);

    let pokemon = await Promise.all(
      pokemonList.results.map(async (pokemon) =>
        getPokemonDataByName(pokemon.name)
      )
    );

    pokemon = filterPokemon(pokemon, filter);
    return {
      props: {
        currentPage: page,
        itemsCount: pokemonList.count,
        pokemon,
        initialLimit: limit.toString(),
        initalFilter: filter.toString(),
      },
    };
  } catch (ex) {
    return { props: { errorMsg: `Something went wrong! ${ex}` } };
  }
};

const getPokemonDataByName = async (name: string) => {
  const api = new PokemonClient({
    cacheOptions: { maxAge: 1000 * 60 * 60 * 24 * 7 },
  });
  const pokemon = await api.getPokemonByName(name);
  return _.pick(pokemon, [
    "id",
    "name",
    "abilities",
    "weight",
    "height",
    "sprites.front_shiny",
  ]);
};

type ResolveLimit = (
  req: IncomingMessage & {
    cookies: Partial<{
      [key: string]: string;
    }>;
  },
  res: ServerResponse<IncomingMessage>,
  query: ParsedUrlQuery
) => number;

const resolveQueryLimit: ResolveLimit = (req, res, query) => {
  if (typeof query.limit === "string") {
    return parseInt(query.limit);
  }

  const parseCookie = parseInt(getCookie("limit", { req, res }) as string);
  if (parseCookie >= 0) {
    return parseCookie;
  }

  return 10;
};

type ResolveFilter = (
  req: IncomingMessage & {
    cookies: Partial<{
      [key: string]: string;
    }>;
  },
  res: ServerResponse<IncomingMessage>,
  query: ParsedUrlQuery
) => string;

const resolveQueryFilter: ResolveFilter = (req, res, query) => {
  if (typeof query.filter === "string") {
    return query.filter;
  }

  const parseCookie = getCookie("filter", { req, res }) as string;
  if (parseCookie) {
    return parseCookie;
  }

  return "asc";
};

function filterPokemon(
  pokemon: Partial<Pokemon>[],
  filter: string
): Partial<Pokemon>[] {
  switch (filter) {
    case "desc":
      return pokemon.sort((a, b) => b.name!.localeCompare(a.name!));

    case "height":
      return pokemon.sort((a, b) => b.height! - a.height!);

    case "weight":
      return pokemon.sort((a, b) => b.weight! - a.weight!);

    default:
      return pokemon.sort((a, b) => a.name!.localeCompare(b.name!));
  }
}
